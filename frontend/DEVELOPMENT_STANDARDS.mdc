---
description:
globs:
alwaysApply: false
---
# ğŸ§‘â€ğŸ’» EstÃ¡ndares de Desarrollo React Vite
Estas reglas aplican a todos los proyectos React Vite desarrollados en SmartUp.

## ğŸ—ï¸ Arquitectura y Estructura del Proyecto

### ğŸ“ OrganizaciÃ³n de Carpetas
```
src/
â”œâ”€â”€ components/           # Componentes reutilizables
â”‚   â”œâ”€â”€ ui/              # Componentes de UI atÃ³micos
â”‚   â”œâ”€â”€ forms/           # Componentes de formularios
â”‚   â””â”€â”€ layout/          # Componentes de layout
â”œâ”€â”€ hooks/               # Custom hooks
â”œâ”€â”€ stores/              # Stores de Zustand
â”œâ”€â”€ services/            # Servicios y APIs
â”œâ”€â”€ utils/               # Utilidades y helpers
â”œâ”€â”€ types/               # Tipos TypeScript (si aplica)
â”œâ”€â”€ constants/           # Constantes globales
â”œâ”€â”€ assets/              # ImÃ¡genes, iconos, etc.
â””â”€â”€ pages/               # PÃ¡ginas/componentes de ruta
```

### ğŸ§© ComponentizaciÃ³n y Modularidad
- **Componentes AtÃ³micos**: Desarrolla componentes granulares y reutilizables
- **Agnosticismo**: Los componentes deben ser agnÃ³sticos respecto a propiedades heredadas
- **Responsabilidad Ãšnica**: Cada componente debe tener una sola responsabilidad
- **MÃ¡ximo 200 lÃ­neas por componente** (preferentemente menos de 150)
- **SeparaciÃ³n de LÃ³gica**: Extrae lÃ³gica compleja a custom hooks

## ğŸ§¹ Clean Code y Convenciones

### ğŸ“ Nomenclatura
- **Componentes**: `PascalCase` (ej: `UserProfile`, `ProductCard`)
- **Hooks**: `camelCase` con prefijo `use` (ej: `useUserData`, `useProductList`)
- **Funciones/Utilidades**: `camelCase` (ej: `formatCurrency`, `validateEmail`)
- **Constantes**: `UPPER_SNAKE_CASE` (ej: `API_ENDPOINTS`, `DEFAULT_CONFIG`)
- **Archivos**: `kebab-case` (ej: `user-profile.jsx`, `product-card.jsx`)

### ğŸ”§ Estructura de Componentes
```jsx
// âœ… Estructura recomendada
import React from 'react'
import PropTypes from 'prop-types'
import { useCustomHook } from '../hooks/useCustomHook'
import { formatData } from '../utils/formatters'

const ComponentName = ({ prop1, prop2, children }) => {
  const { data, loading } = useCustomHook()

  if (loading) return <LoadingSpinner />

  return (
    <div className="component-container">
      {children}
    </div>
  )
}

ComponentName.propTypes = {
  prop1: PropTypes.string.isRequired,
  prop2: PropTypes.number,
  children: PropTypes.node
}

ComponentName.defaultProps = {
  prop2: 0
}

export default ComponentName
```

## ğŸ£ GestiÃ³n de Estado

### ğŸ“Š Zustand Stores
- **Un store por dominio** (ej: `userStore`, `productStore`)
- **Acciones claras y descriptivas**
- **SeparaciÃ³n de estado y lÃ³gica de negocio**

```jsx
// âœ… Ejemplo de store bien estructurado
import { createStore } from 'zustand'

const useUserStore = createStore((set, get) => ({
  // Estado
  user: null,
  isLoading: false,
  error: null,

  // Acciones
  setUser: (user) => set({ user, error: null }),
  setLoading: (isLoading) => set({ isLoading }),
  setError: (error) => set({ error, isLoading: false }),

  // Acciones complejas
  loginUser: async (credentials) => {
    set({ isLoading: true, error: null })
    try {
      const user = await authService.login(credentials)
      set({ user, isLoading: false })
    } catch (error) {
      set({ error: error.message, isLoading: false })
    }
  }
}))
```

### ğŸ¯ Custom Hooks
- **Extrae lÃ³gica compleja** de componentes a custom hooks
- **Prefijo `use`** obligatorio
- **Retorna objetos estructurados** con estado y acciones

```jsx
// âœ… Custom hook bien estructurado
const useProductList = (categoryId) => {
  const [products, setProducts] = useState([])
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState(null)

  const fetchProducts = useCallback(async () => {
    setLoading(true)
    try {
      const data = await productService.getByCategory(categoryId)
      setProducts(data)
    } catch (err) {
      setError(err.message)
    } finally {
      setLoading(false)
    }
  }, [categoryId])

  useEffect(() => {
    fetchProducts()
  }, [fetchProducts])

  return {
    products,
    loading,
    error,
    refetch: fetchProducts
  }
}
```

## ğŸŒ GestiÃ³n de Datos y APIs

### ğŸ“¡ TanStack Query + Alova
- **Usa TanStack Query** para gestiÃ³n de estado del servidor
- **Implementa Alova** para peticiones HTTP (evita fetch nativo)
- **ConfiguraciÃ³n centralizada** de queries

```jsx
// âœ… ConfiguraciÃ³n de TanStack Query
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5 minutos
      cacheTime: 10 * 60 * 1000, // 10 minutos
      retry: 3,
      refetchOnWindowFocus: false
    }
  }
})

// âœ… Uso de queries
const useProducts = (categoryId) => {
  return useQuery({
    queryKey: ['products', categoryId],
    queryFn: () => productService.getByCategory(categoryId),
    enabled: !!categoryId
  })
}
```

### ğŸ”„ OptimizaciÃ³n de Rendimiento
- **React.memo** para componentes que reciben props estables
- **useMemo** para cÃ¡lculos costosos
- **useCallback** para funciones que se pasan como props
- **Lazy loading** para componentes grandes

## ğŸ¨ Estilos y UI

### ğŸ¯ Tailwind CSS
- **Utiliza clases de Tailwind** de manera consistente
- **Crea componentes de UI atÃ³micos** para elementos reutilizables
- **Evita estilos inline** y CSS personalizado innecesario
- **Usa variables CSS** para temas y colores

```jsx
// âœ… Componente UI atÃ³mico
const Button = ({
  variant = 'primary',
  size = 'md',
  children,
  ...props
}) => {
  const baseClasses = 'font-medium rounded-lg transition-colors focus:outline-none focus:ring-2'

  const variants = {
    primary: 'bg-blue-600 hover:bg-blue-700 text-white focus:ring-blue-500',
    secondary: 'bg-gray-200 hover:bg-gray-300 text-gray-800 focus:ring-gray-500',
    danger: 'bg-red-600 hover:bg-red-700 text-white focus:ring-red-500'
  }

  const sizes = {
    sm: 'px-3 py-1.5 text-sm',
    md: 'px-4 py-2 text-base',
    lg: 'px-6 py-3 text-lg'
  }

  return (
    <button
      className={`${baseClasses} ${variants[variant]} ${sizes[size]}`}
      {...props}
    >
      {children}
    </button>
  )
}
```

## ğŸ§ª Testing y Calidad

### âœ… Tests Unitarios
- **Cobertura mÃ­nima del 80%** para lÃ³gica de negocio
- **Tests para custom hooks** y utilidades
- **Tests de componentes** con React Testing Library
- **Mocks apropiados** para servicios externos

### ğŸ” Code Quality
- **ESLint** configurado con reglas estrictas
- **Prettier** para formateo consistente
- **Husky** para pre-commit hooks
- **TypeScript** recomendado para proyectos grandes

## ğŸ“š DocumentaciÃ³n

### ğŸ“– README y DocumentaciÃ³n
- **README actualizado** con cada nueva feature
- **DocumentaciÃ³n de componentes** con Storybook (recomendado)
- **Comentarios JSDoc** para funciones complejas
- **Ejemplos de uso** en documentaciÃ³n

### ğŸ·ï¸ PropTypes y TypeScript
```jsx
// âœ… PropTypes bien definidos
ComponentName.propTypes = {
  // Props requeridas
  title: PropTypes.string.isRequired,

  // Props opcionales con valores por defecto
  variant: PropTypes.oneOf(['primary', 'secondary', 'danger']),
  size: PropTypes.oneOf(['sm', 'md', 'lg']),

  // Funciones
  onSubmit: PropTypes.func,

  // Elementos React
  children: PropTypes.node,

  // Arrays y objetos
  items: PropTypes.arrayOf(PropTypes.shape({
    id: PropTypes.string.isRequired,
    name: PropTypes.string.isRequired
  }))
}
```

## ğŸš€ Patrones de DiseÃ±o

### ğŸ­ Higher-Order Components (HOC)
- **Usa HOCs** para lÃ³gica transversal (auth, loading, error handling)
- **ComposiciÃ³n sobre herencia**
- **MantÃ©n HOCs simples** y enfocados

```jsx
// âœ… HOC bien estructurado
const withErrorBoundary = (WrappedComponent) => {
  return function ErrorBoundaryWrapper(props) {
    const [hasError, setHasError] = useState(false)

    if (hasError) {
      return <ErrorFallback onRetry={() => setHasError(false)} />
    }

    return (
      <ErrorBoundary onError={() => setHasError(true)}>
        <WrappedComponent {...props} />
      </ErrorBoundary>
    )
  }
}
```

### ğŸ”„ Render Props y Compound Components
- **Usa render props** para lÃ³gica reutilizable
- **Compound components** para componentes complejos
- **Flexibilidad en la API** de componentes

## ğŸ”’ Seguridad y Mejores PrÃ¡cticas

### ğŸ›¡ï¸ Seguridad
- **ValidaciÃ³n de inputs** en el frontend
- **SanitizaciÃ³n de datos** antes de renderizar
- **HTTPS obligatorio** en producciÃ³n
- **Headers de seguridad** configurados

### âš¡ Performance
- **Code splitting** con React.lazy
- **Bundle analysis** regular
- **OptimizaciÃ³n de imÃ¡genes** y assets
- **Caching estratÃ©gico** con TanStack Query

## ğŸ“‹ Checklist de RevisiÃ³n

### âœ… Antes de hacer commit:
- [ ] CÃ³digo sigue convenciones de nomenclatura
- [ ] Componentes no exceden 200 lÃ­neas
- [ ] Custom hooks extraÃ­dos para lÃ³gica compleja
- [ ] Tests escritos para nueva funcionalidad
- [ ] PropTypes/TypeScript definidos
- [ ] README actualizado
- [ ] No hay console.log o cÃ³digo de debug
- [ ] Performance optimizada (memo, useMemo, useCallback)
- [ ] Accesibilidad considerada
- [ ] Responsive design implementado

### ğŸš¨ Anti-patrones a Evitar:
- âŒ Componentes monolÃ­ticos con mÃºltiples responsabilidades
- âŒ Uso excesivo de useState y useEffect en un componente
- âŒ Fetch nativo sin librerÃ­as especializadas
- âŒ LÃ³gica de negocio en componentes
- âŒ Props drilling excesivo
- âŒ Re-renders innecesarios
- âŒ Dependencias circulares
- âŒ CÃ³digo duplicado

---

**Recuerda**: La calidad del cÃ³digo es responsabilidad de todo el equipo. Revisa y refactoriza constantemente para mantener estÃ¡ndares altos.
